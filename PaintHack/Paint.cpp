#include "Paint.h"

#pragma region Spielfelder

short StartField[40][40] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

short PlayField[40][40] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

short PlayFieldLevelTwo[40][40] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

short PlayFieldLevelThree[40][40] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1},
	{1,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,0,0,0,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

short PlayFieldLevelFour[40][40] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

#pragma endregion

#pragma region Zahlen
short Zero[5][3] = {
	{1,1,1},
	{1,0,1},
	{1,0,1},
	{1,0,1},
	{1,1,1} };
short One[5][3] = {
	{0,0,1},
	{0,0,1},
	{0,0,1},
	{0,0,1},
	{0,0,1} };
short Two[5][3] = {
	{1,1,1},
	{0,0,1},
	{1,1,1},
	{1,0,0},
	{1,1,1} };
short Three[5][3] = {
	{1,1,1},
	{0,0,1},
	{1,1,1},
	{0,0,1},
	{1,1,1} };
short Four[5][3] = {
	{1,0,1},
	{1,0,1},
	{1,1,1},
	{0,0,1},
	{0,0,1} };
short Five[5][3] = {
	{1,1,1},
	{1,0,0},
	{1,1,1},
	{0,0,1},
	{1,1,1} };
short Six[5][3] = {
	{1,1,1},
	{1,0,0},
	{1,1,1},
	{1,0,1},
	{1,1,1} };
short Seven[5][3] = {
	{1,1,1},
	{0,0,1},
	{0,0,1},
	{0,0,1},
	{0,0,1} };
short Eight[5][3] = {
	{1,1,1},
	{1,0,1},
	{1,1,1},
	{1,0,1},
	{1,1,1} };
short Nine[5][3] = {
	{1,1,1},
	{1,0,1},
	{1,1,1},
	{0,0,1},
	{0,0,1} };
#pragma endregion


/// <summary>
/// Konstruktor
/// </summary>
Paint::Paint(int mlevel) {
	level = mlevel;
	if (mlevel == 2) {
		for (int x = 0; x < Blocks; x++) {
			for (int y = 0; y < Blocks; y++) {
				PlayField[x][y] = PlayFieldLevelTwo[x][y];
			}
		}
		SpawnAFruit();
	}
	else if (mlevel == 3) {
		for (int x = 0; x < Blocks; x++) {
			for (int y = 0; y < Blocks; y++) {
				PlayField[x][y] = PlayFieldLevelThree[x][y];
			}
		}
		SpawnAFruit();
		SpawnAFruit();
	}
	else if (mlevel == 4) {
		for (int x = 0; x < Blocks; x++) {
			for (int y = 0; y < Blocks; y++) {
				PlayField[x][y] = PlayFieldLevelFour[x][y];
			}
		}
		SpawnAFruit();
		SpawnAFruit();
		SpawnAFruit();
	}


	ColorType.insert(std::pair<FieldType, Color>(FieldType::None, Color(std::array<double, 3>({ 34,177,76 }))));
	ColorType.insert(std::pair<FieldType, Color>(FieldType::Fruit, Color(std::array<double, 3>({ 237,28,36 }))));
	ColorType.insert(std::pair<FieldType, Color>(FieldType::Snake, Color(std::array<double, 3>({ 128,128,0 }))));
	ColorType.insert(std::pair<FieldType, Color>(FieldType::SnakeHead, Color(std::array<double, 3>({ 128,100,0 }))));
	ColorType.insert(std::pair<FieldType, Color>(FieldType::Wall, Color(std::array<double, 3>({ 128,128,128 }))));
	ColorType.insert(std::pair<FieldType, Color>(FieldType::ColorPlane, Color(std::array<double, 3>({ 95,95,95 }))));
	PaintArea = new BYTE[Width * Height * 3];
	//Hier liegen die Werte nach RGB Sch
	DefaultBackColor = { 162, 232, 0 };
	ClearScreen();
	level = mlevel;
	//Snakeposition Initialisieren
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> distr((int)(Blocks / 2) - (int)(Blocks / 4), (int)(Blocks / 2) + (int)(Blocks / 4));

	POINT HeadPosition({ distr(gen),distr(gen) });
	PlayField[HeadPosition.x][HeadPosition.y] = (int)FieldType::SnakeHead;
	MySnake.push_back(HeadPosition);

	POINT BodyPositionOne({ HeadPosition.x, HeadPosition.y - 1 });
	PlayField[BodyPositionOne.x][BodyPositionOne.y] = (int)FieldType::Snake;
	MySnake.push_back(BodyPositionOne);

	POINT BodyPositionTwo({ BodyPositionOne.x, BodyPositionOne.y - 1 });
	PlayField[BodyPositionTwo.x][BodyPositionTwo.y] = (int)FieldType::Snake;
	MySnake.push_back(BodyPositionTwo);




	//Frucht Spawnen
	SpawnAFruit();

	//Fielddaten schreiben
	CreateFieldData();
}

/// <summary>
/// Dstruktor
/// </summary>
Paint::~Paint() {
	delete[] PaintArea;
	DrawArea.clear();
}

/// <summary>
/// Gibt die Länge eines Eindimensionalen Arrays zurück, 
/// welches unsere Zeichenfläche repräsentiert.
/// </summary>
/// <returns></returns>
int Paint::getLength() {
	return (Width * Height) * 3;
}


/// <summary>
/// Erstellt das Feld mit den Werten None und Wall
/// </summary>
void Paint::CreateFieldData() {

	int widthBlock = Width / Blocks;
	int heightBlock = Height / Blocks;

	for (int y = 0; y < Blocks; y++) {
		for (int x = 0; x < Blocks; x++) {

			//Farbe des aktuellen Pixels bestimmen
			auto ty = (FieldType)PlayField[x][y];
			Color curColor = ColorType.find(ty)->second;
			//Pixel vom aktuellen Punkt sammeln
			int xx = x * widthBlock;
			int yy = y * heightBlock;

			for (int jy = yy; jy < (yy + heightBlock); jy++) {
				for (int jx = xx; jx < (xx + widthBlock); jx++) {
					SetColorFromPixel({ jx,jy }, curColor);
				}
			}
		}
	}
}


/// <summary>
/// Setzt den kompletten Screen auf die 
/// Default Farbe zurück.
/// </summary>
void Paint::ClearScreen() {
	DrawArea.clear();
	int size = Width * Height;
	for (int i = 0; i < size; i++) {
		Color clr(DefaultBackColor);
		DrawArea.push_back(clr);
	}
}

/// <summary>
/// Bewge Snake in eine neue, 
/// oder die aktuelle Richtung.
/// </summary>
/// <param name="dir"></param>
void Paint::MoveSnake(MoveDirection dir) {
	if (!isAlive) return;	// Nur bewegen wenn die Snake am leben ist.

	std::vector<POINT> RefreshArea; //Hier Pixel/Positionen speichern die aktualisiert werden sollen.
	RefreshArea.insert(RefreshArea.end(), MySnake.begin(), MySnake.end());	//Alle Daten einfügen

	POINT Tail = MySnake.back();
	POINT Head = MySnake.front();

	if (dir == MoveDirection::Stand) {
		auto nextPos = GetNextPosition(curMoveDir);
		if (!CanGoForward(nextPos)) {
			isAlive = false; //Snake DEAD
			return;
		}
		if (IsFruit(nextPos)) {
			SnakeExtend(nextPos);
			RefreshArea.push_back(SpawnAFruit());
			RefreshArea.push_back(nextPos);
		}
		else {
			//Die Schlange bewegt sich eines nach vorne. Der letzte Punkt muss also None werden
			for (auto p : MySnake)
				PlayField[p.x][p.y] = (int)FieldType::Snake;
			PlayField[Tail.x][Tail.y] = (int)FieldType::None;
			MySnake.insert(MySnake.begin(), nextPos);
			RefreshArea.push_back(nextPos);
			MySnake.pop_back();
			PlayField[nextPos.x][nextPos.y] = (int)FieldType::SnakeHead;
		}
	}
	else {
		curMoveDir = dir;
		auto nextPos = GetNextPosition(curMoveDir);
		if (!CanGoForward(nextPos)) {
			isAlive = false; //Snake DEAD
			return;
		}
		if (IsFruit(nextPos)) {
			SnakeExtend(nextPos);
			RefreshArea.push_back(SpawnAFruit());
			RefreshArea.push_back(nextPos);
		}
		else {
			//Die Schlange bewegt sich eines nach vorne. Der letzte Punkt muss also None werden
			MySnake.pop_back();
			for (auto p : MySnake)
				PlayField[p.x][p.y] = (int)FieldType::Snake;
			PlayField[Tail.x][Tail.y] = (int)FieldType::None;
			MySnake.insert(MySnake.begin(), nextPos);
			RefreshArea.push_back(nextPos);
			PlayField[nextPos.x][nextPos.y] = (int)FieldType::SnakeHead;
		}
	}

	RefreshBlockArea(RefreshArea);
}

/// <summary>
/// Aktualisiert die Punkte
/// </summary>
/// <param name="points"></param>
void Paint::RefreshBlockArea(std::vector<POINT> points) {

	int widthBlock = Width / Blocks;
	int heightBlock = Height / Blocks;

	for (auto pk : points) {

		//Farbe des aktuellen Pixels bestimmen
		auto ty = (FieldType)PlayField[pk.x][pk.y];
		Color curColor = ColorType.find(ty)->second;
		//Pixel vom aktuellen Punkt sammeln
		int xx = pk.x * widthBlock;
		int yy = pk.y * heightBlock;

		for (int jy = yy; jy < (yy + heightBlock); jy++) {
			for (int jx = xx; jx < (xx + widthBlock); jx++) {
				SetColorFromPixel({ jx,jy }, curColor);
			}
		}

	}

}

/// <summary>
/// Display zeichnen
/// </summary>
void Paint::DisplayPoints() {
	if (isAlive) return;

	for (int x = 0; x < Blocks; x++) {
		for (int y = 0; y < Blocks; y++) {
			PlayField[x][y] = (int)FieldType::None;
		}
	}

	MySnake.clear();

	auto punkte = std::to_string(myPoints);
	int str = 5;
	for (auto chr : punkte) {
		if (chr == '0') {
			for (int y = 0; y < 5; y++) {
				for (int x = 0; x < 3; x++) {
					if (Zero[y][x] == (short)1) {
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
					}
				}
			}
		}
		else if (chr == '1') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (One[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '2') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Two[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '3') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Three[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '4') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Four[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '5') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Five[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '6') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Six[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '7') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Seven[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '8') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Eight[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		else if (chr == '9') {
			for (int y = 0; y < 5; y++)
				for (int x = 0; x < 3; x++) {
					if (Nine[y][x] == 1)
						PlayField[x + str][y + 5] = (int)FieldType::Wall;
				}
		}
		str += 4;
		if (str > Blocks) break;
	}
	RefreshDisplay();
}

/// <summary>
/// Manueller Refresh der Daten
/// </summary>
void Paint::RefreshDisplay() {
	int widthBlock = Width / Blocks;
	int heightBlock = Height / Blocks;
	for (int y = 0; y < Blocks; y++) {
		for (int x = 0; x < Blocks; x++) {
			auto ty = (FieldType)PlayField[x][y];
			Color curColor = ColorType.find(ty)->second;
			int xx = x * widthBlock;
			int yy = y * heightBlock;
			for (int jy = yy; jy < (yy + heightBlock); jy++) {
				for (int jx = xx; jx < (xx + widthBlock); jx++) {
					SetColorFromPixel({ jx,jy }, curColor);
				}
			}
		}
	}
}

/// <summary>
/// Spawnt Random eine Frucht.
/// </summary>
POINT Paint::SpawnAFruit() {
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> distr(1, Blocks - 1);
	POINT result;
	while (true) {
		POINT tmp({ distr(gen),distr(gen) });
		if (PlayField[tmp.x][tmp.y] == (int)FieldType::None) {
			PlayField[tmp.x][tmp.y] = (int)FieldType::Fruit;
			std::cout << "Frucht gespawnt." << std::endl;
			result = tmp;
			break;
		}
	}
	return result;
}

/// <summary>
/// Gibt die neue Position des SnakeKopfes zurück
/// </summary>
/// <param name="dir">Die Richtung in die der Kopf sich bewegen soll.</param>
/// <returns></returns>
POINT Paint::GetNextPosition(MoveDirection dir) {
	switch (dir) {
	case Stand:
		return POINT({ MySnake[0].x, MySnake[0].y });	//<-- Hier sollte kein None übergeben werden. Sollte es doch der fall sein wird die aktuelle Position zurück gegeben
	case Left:
		return POINT({ MySnake[0].x - 1, MySnake[0].y });
	case Up:
		return POINT({ MySnake[0].x, MySnake[0].y - 1 });
	case Right:
		return POINT({ MySnake[0].x + 1, MySnake[0].y });
	case Down:
		return POINT({ MySnake[0].x, MySnake[0].y + 1 });
	default:
		return POINT({ MySnake[0].x, MySnake[0].y });
	}
}



/// <summary>
/// Verlängert die Snake und aktualisiert das Feld
/// </summary>
/// <param name="fruit">Position der Frucht.</param>
void Paint::SnakeExtend(POINT fruit) {
	myPoints += (MySnake.size() * level);
	std::cout << "Aktuelle Punkte: " << myPoints << std::endl;
	for (auto pk : MySnake) {
		PlayField[pk.x][pk.y] = (int)FieldType::Snake;
	}
	MySnake.insert(MySnake.begin(), fruit);
	PlayField[fruit.x][fruit.y] = (int)FieldType::SnakeHead;
}


/// <summary>
/// Überprüft ob der Punkt Begehbar ist.
/// Nicht begehbar wäre z.B. Wall
/// </summary>
/// <param name="pkt">Der Punkt</param>
/// <returns></returns>
bool Paint::CanGoForward(POINT pkt) {
	if (PlayField[pkt.x][pkt.y] == (int)(FieldType::Wall)) {
		return false;
	}
	for (auto pk : MySnake) {
		if (pk.x == pkt.x && pk.y == pkt.y) return false;
	}
	return true;
}

/// <summary>
/// Überprüft ob der Punkt eine Frucht ist.
/// </summary>
/// <param name="pkt">Der zu überprüfende Punkt</param>
/// <returns></returns>
bool Paint::IsFruit(POINT pkt) {
	if (PlayField[pkt.x][pkt.y] == (int)(FieldType::Fruit)) {
		return true;
	}
	return false;
}

/// <summary>
/// Gibt die aktuelle Punktzahl zurück
/// </summary>
/// <returns></returns>
int Paint::GetPoints() {
	return myPoints;
}

/// <summary>
/// Erstellt ein Array aus Pixeldaten,
/// die in den Speicher geladen werden können.
/// </summary>
/// <returns></returns>
BYTE* Paint::CreatePixelData() {
	//Beachten müssen wir die ablage der Daten. Angefangen mit x = 0; y = max 
	//Dann nach -> und bei x = Max Y--
	int x = 0;
	int y = Height - 1; //Nullbasierend wurde das Array angelegt!
	int ix = 0;
	while (x < Width && y != 0) {
		auto px = GetPixelFromOffset({ x,y });
		PaintArea[ix] = px.rgb[2]; ix++;
		PaintArea[ix] = px.rgb[1]; ix++;
		PaintArea[ix] = px.rgb[0]; ix++;
		if (x == Width - 1) {
			x = 0;
			y--;
		}
		else {
			x++;
		}
	}
	return PaintArea;
}


/// <summary>
/// Erstellt einen Startscreen
/// </summary>
/// <returns></returns>
BYTE* Paint::CreateStartScreen(){

	int widthBlock = Width / Blocks;
	int heightBlock = Height / Blocks;

	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> distr(0, 255);

	auto clr = Color({ (double)distr(gen),(double)distr(gen),(double)distr(gen) });
	auto font = Color({ (double)distr(gen),(double)distr(gen),(double)distr(gen) });


	int x = 0;
	int y = Height - 1; //Nullbasierend wurde das Array angelegt!
	int ix = 0;

	while (x < Width && y != 0) {

		int xxBlock = (int)(x / (Blocks / 4));
		int yyBlock = (int)(y / (Blocks / 4));

		if (StartField[yyBlock][xxBlock] == 0) {
			PaintArea[ix] = clr.rgb[2]; ix++;
			PaintArea[ix] = clr.rgb[1]; ix++;
			PaintArea[ix] = clr.rgb[0]; ix++;
		}
		else {
			PaintArea[ix] = font.rgb[2]; ix++;
			PaintArea[ix] = font.rgb[1]; ix++;
			PaintArea[ix] = font.rgb[0]; ix++;
		}
	
		if (x == Width - 1) {
			x = 0;
			y--;
		}
		else {
			x++;
		}
	}

	return PaintArea;
}

/// <summary>
/// Ließt eine Farbe aus dem Array aus.
/// </summary>
/// <param name="pkt"></param>
/// <returns></returns>
Color Paint::GetPixelFromOffset(POINT pkt) {
	int yy = Width * pkt.y;
	int vx = yy + pkt.x;
	if (vx > (Width * Height)) throw std::invalid_argument("Der Wert des Pixels übersteigt der des Arrays!");
	return DrawArea[vx];
}

void Paint::SetColorFromPixel(POINT pt, Color clr) {
	int yy = Width * pt.y;
	int vx = yy + pt.x;
	if (vx > (Width * Height)) throw std::invalid_argument("Der Wert des Pixels übersteigt der des Arrays!");
	DrawArea[vx] = clr;
}